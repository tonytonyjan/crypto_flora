<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SHA-256 Botanical Art Generator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            background-color: #0f172a;
            color: #e2e8f0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        .canvas-container {
            box-shadow: 0 0 50px rgba(0, 0, 0, 0.5);
            background-image: radial-gradient(circle at center, #1e293b 0%, #0f172a 100%);
        }
        /* Custom scrollbar for the hex display */
        .hex-scroll::-webkit-scrollbar {
            height: 6px;
        }
        .hex-scroll::-webkit-scrollbar-track {
            background: #1e293b;
        }
        .hex-scroll::-webkit-scrollbar-thumb {
            background: #475569;
            border-radius: 3px;
        }
    </style>
</head>
<body class="min-h-screen flex flex-col items-center justify-center p-4">

    <div class="max-w-4xl w-full flex flex-col items-center gap-6">
        
        <!-- Header -->
        <div class="text-center space-y-2">
            <h1 class="text-4xl font-light tracking-wider text-cyan-400">Crypto<span class="font-bold text-pink-500">Flora</span></h1>
            <p class="text-slate-400 text-sm">Visualizing SHA-256 Hashes in Polar Coordinates</p>
        </div>

        <!-- Main Interface -->
        <div class="bg-slate-800/50 p-6 rounded-2xl border border-slate-700 w-full backdrop-blur-sm">
            <div class="flex flex-col md:flex-row gap-4 mb-6">
                <input type="text" id="inputString" placeholder="Type anything here to grow a flower..." 
                    class="flex-1 bg-slate-900 border border-slate-600 rounded-lg px-4 py-3 text-lg focus:outline-none focus:border-cyan-500 transition-colors text-white placeholder-slate-500">
                <button id="randomBtn" class="bg-slate-700 hover:bg-slate-600 text-white font-medium px-6 py-3 rounded-lg transition-colors">
                    Random
                </button>
            </div>

            <div class="flex flex-col items-center gap-6">
                <!-- Canvas Wrapper -->
                <div class="relative group">
                    <canvas id="artCanvas" width="800" height="800" class="canvas-container rounded-full max-w-full h-auto w-[300px] md:w-[500px] border-4 border-slate-700/50 cursor-pointer transition-transform duration-500 hover:scale-[1.02]"></canvas>
                    <div class="absolute bottom-4 right-4 opacity-0 group-hover:opacity-100 transition-opacity">
                        <button id="downloadBtn" class="bg-slate-900/80 hover:bg-black text-white p-2 rounded-full backdrop-blur-md border border-slate-600" title="Download Image">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line></svg>
                        </button>
                    </div>
                </div>

                <!-- Hash Display -->
                <div class="w-full space-y-2">
                    <div class="flex justify-between text-xs text-slate-400 uppercase tracking-widest">
                        <span>SHA-256 Hash Output (32 Bytes)</span>
                        <span id="byteCount">256 bits</span>
                    </div>
                    <div id="hashDisplay" class="hex-scroll font-mono text-xs md:text-sm bg-black/40 p-4 rounded-lg text-emerald-400 break-all border border-emerald-900/30 overflow-x-auto whitespace-nowrap">
                        Type something to see the hash...
                    </div>
                </div>
            </div>
        </div>

        <!-- Controls / Legend -->
        <div class="grid grid-cols-1 md:grid-cols-3 gap-4 w-full text-sm text-slate-400">
            <div class="bg-slate-800/30 p-4 rounded-lg border border-slate-700/50">
                <h3 class="text-cyan-400 font-semibold mb-1">Geometry</h3>
                <p>Bytes 0-4 control petal count, rotational symmetry, and sharpness.</p>
            </div>
            <div class="bg-slate-800/30 p-4 rounded-lg border border-slate-700/50">
                <h3 class="text-pink-400 font-semibold mb-1">Color Palette</h3>
                <p>Bytes 5-12 determine hue, saturation, lightness, and gradients.</p>
            </div>
            <div class="bg-slate-800/30 p-4 rounded-lg border border-slate-700/50">
                <h3 class="text-amber-400 font-semibold mb-1">Mutation</h3>
                <p>Remaining bytes add noise, inner details, and harmonic layers.</p>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('artCanvas');
        const ctx = canvas.getContext('2d');
        const input = document.getElementById('inputString');
        const hashDisplay = document.getElementById('hashDisplay');
        
        let currentHashBytes = null;

        // Initialize with a default word
        window.addEventListener('load', () => {
            input.value = "Nature";
            generateArt();
        });

        input.addEventListener('input', generateArt);

        document.getElementById('randomBtn').addEventListener('click', () => {
            const randomWords = ["Cosmos", "Quantum", "Nebula", "Aether", "Fractal", "Entropy", "Zenith", "Horizon", "Eclipse", "Aurora"];
            input.value = randomWords[Math.floor(Math.random() * randomWords.length)] + " " + Math.floor(Math.random() * 1000);
            generateArt();
        });

        document.getElementById('downloadBtn').addEventListener('click', () => {
            const link = document.createElement('a');
            link.download = `crypto-flower-${Date.now()}.png`;
            link.href = canvas.toDataURL();
            link.click();
        });

        async function generateArt() {
            const text = input.value || " ";
            
            // 1. Calculate SHA-256 Hash
            const msgBuffer = new TextEncoder().encode(text);
            const hashBuffer = await crypto.subtle.digest('SHA-256', msgBuffer);
            const hashArray = Array.from(new Uint8Array(hashBuffer));
            currentHashBytes = hashArray;

            // Update UI with Hex String
            const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
            hashDisplay.innerHTML = hashHex.match(/.{1,2}/g).join(' '); // Add spaces for readability

            // 2. Draw
            drawFlower(hashArray);
        }

        function drawFlower(bytes) {
            const w = canvas.width;
            const h = canvas.height;
            const cx = w / 2;
            const cy = h / 2;

            // Clear Canvas
            ctx.clearRect(0, 0, w, h);
            
            // Background Glow (Subtle)
            const bgHue = bytes[10] % 360;
            const gradient = ctx.createRadialGradient(cx, cy, 50, cx, cy, w/1.5);
            gradient.addColorStop(0, `hsla(${bgHue}, 60%, 15%, 1)`);
            gradient.addColorStop(1, 'rgba(15, 23, 42, 0)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, w, h);

            // --- Parameter Extraction from Hash (32 bytes available) ---
            
            // Core Geometry
            // Byte 0: Base Petal Count (3 to 14)
            const petalCount = (bytes[0] % 12) + 3; 
            
            // Byte 1: Shape Factor (Sharpness vs Roundness)
            const shapeFactor = (bytes[1] / 255) * 2 + 0.5; // 0.5 to 2.5
            
            // Byte 2: Layer Count (3 to 8 layers)
            const layers = (bytes[2] % 6) + 3;

            // Colors
            // Byte 5: Base Hue
            const baseHue = (bytes[5] << 8 | bytes[6]) % 360; // Use 2 bytes for full 360 range resolution
            // Byte 7: Saturation Strategy
            const satBase = 60 + (bytes[7] % 40); // 60-100%

            // Global Rotation
            const rotationOffset = (bytes[3] / 255) * Math.PI * 2;

            ctx.save();
            ctx.translate(cx, cy);
            ctx.rotate(rotationOffset);

            // Calculate safe base radius to ensure no clipping
            // Max potential expansion is 1.0 (base) + 0.4 (amp) + 0.2 (harmonic) = 1.6x
            const maxDimension = Math.min(w, h) / 2;
            const safeBaseRadius = (maxDimension * 0.9) / 1.6;

            // Draw Layers from Outside In
            for (let i = layers; i > 0; i--) {
                const layerNorm = i / layers; // 1.0 down to ~0.1
                const radius = safeBaseRadius * layerNorm; 
                
                // Each layer uses different bytes for variation to ensure uniqueness
                const layerByteA = bytes[(i * 2) % 32];
                const layerByteB = bytes[(i * 2 + 1) % 32];

                // Amplitude modulation for this layer
                const amp = radius * (0.1 + (layerByteA / 255) * 0.3);
                
                // Color for this layer
                const hueShift = (layerByteB % 60) - 30; // +/- 30 degrees
                const lightness = 20 + (layerNorm * 60); // Darker outside, lighter inside
                const alpha = 0.7 + (layerNorm * 0.3);
                
                ctx.beginPath();
                
                // Polar Loop
                // Higher resolution for smooth curves
                const steps = 360 * 2; 
                for (let j = 0; j <= steps; j++) {
                    const theta = (j / steps) * Math.PI * 2;
                    
                    // The "Rose" Equation with noise
                    // r = radius + amp * cos(k * theta)
                    // We add a second harmonic based on hash to make it unique and "organic"
                    
                    // Harmonic modifiers
                    const k2 = (bytes[8] % 5) + 2; // Secondary frequency
                    const harmonicAmp = (bytes[9] / 255) * 0.5 * amp;
                    
                    let r = radius + 
                            (Math.pow(Math.abs(Math.cos(petalCount * theta / 2)), shapeFactor) * amp * (layerByteA > 128 ? 1 : -1)) + 
                            (Math.sin(k2 * theta * petalCount) * harmonicAmp);

                    // Clamp radius
                    if (r < 0) r = 0;

                    const x = r * Math.cos(theta);
                    const y = r * Math.sin(theta);

                    if (j === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }

                ctx.closePath();

                // Styling
                ctx.fillStyle = `hsla(${baseHue + hueShift}, ${satBase}%, ${lightness}%, ${alpha})`;
                // Add a composite mode for the "glowing" intersection effect on some layers
                if (bytes[4] > 200 && i % 2 === 0) {
                    ctx.globalCompositeOperation = 'screen';
                } else {
                    ctx.globalCompositeOperation = 'source-over';
                }
                
                ctx.fill();
                
                // Stroke outline for definition
                ctx.lineWidth = 1 + (layerNorm * 2);
                ctx.strokeStyle = `hsla(${baseHue + hueShift}, ${satBase}%, ${Math.min(lightness + 20, 100)}%, 0.8)`;
                ctx.stroke();
            }

            // Central Detail (Stamen/Pistil area)
            // Use bytes 28-31
            const centerRadius = (bytes[28] % 30) + 10;
            ctx.beginPath();
            ctx.arc(0, 0, centerRadius, 0, Math.PI * 2);
            ctx.fillStyle = `hsla(${(baseHue + 180) % 360}, 80%, 80%, 1)`; // Complementary color
            ctx.fill();
            
            // Decorate center
            const centerDots = (bytes[29] % 8) + 4;
            for(let d=0; d<centerDots; d++) {
                const dotAngle = (d / centerDots) * Math.PI * 2;
                const dotR = centerRadius * 0.7;
                const dx = Math.cos(dotAngle) * dotR;
                const dy = Math.sin(dotAngle) * dotR;
                ctx.beginPath();
                ctx.arc(dx, dy, 2, 0, Math.PI*2);
                ctx.fillStyle = '#fff';
                ctx.fill();
            }

            ctx.restore();
        }
    </script>
</body>
</html>